# 查看表大小

参考网址：https://www.shuzhiduo.com/A/A7zg8ga1J4/

```sql
--pg_size_pretty(bigint)	text	Converts a size in bytes expressed as a 64-bit integer into a human-readable format with size units
--pg_size_pretty(numeric)	text	把以字节计算的数值转换成一个人类易读的尺寸单位
--查看指定表大小******************查看指定表大小******************查看指定表大小******************查看指定表大小
 --pg_relation_size(relation regclass, fork text)	bigint	指定OID或名的表或索引，通过指定fork('main', 'fsm' 或'vm')所使用的磁盘空间
pg_relation_size(relation regclass)	bigint	pg_relation_size(..., 'main')的缩写
select pg_relation_size('sfctransactionetl_wzs');
select pg_size_pretty(pg_relation_size('sfctransactionetl_wzs'));
--pg_table_size(regclass)	bigint	指定表OID或表名的表使用的磁盘空间，除去索引（但是包含TOAST，自由空间映射和可视映射）
select pg_table_size('sfctransactionetl_wzs');
select pg_size_pretty(pg_table_size('sfctransactionetl_wzs'));
--查看指定表的总大小******************查看指定表的总大小******************查看指定表的总大小******************
--pg_total_relation_size(regclass)	bigint	指定表OID或表名使用的总磁盘空间，包括所有索引和TOAST数据
select pg_total_relation_size('sfctransactionetl_wzs');
select pg_size_pretty(pg_total_relation_size('sfctransactionetl_wzs'));
--查看指定schema 里所有的表大小，按从大到小的顺序排列。
select relname, pg_size_pretty(pg_relation_size(relid)) from pg_stat_user_tables where schemaname='public' order by pg_relation_size(relid) desc;
--查看数据库大小******************查看数据库大小******************查看数据库大小******************
--pg_database_size(oid)	bigint	指定OID的数据库使用的磁盘空间
--pg_database_size(name)	bigint	指定名称的数据库使用的磁盘空间
select pg_size_pretty(pg_database_size('cim'));
--查看所有数据库大小******************查看所有数据库大小******************查看所有数据库大小******************
select pg_database.datname,pg_size_pretty(pg_database_size(pg_database.datname))  AS size from pg_database;

```

# 释放空间

参考网址：https://blog.csdn.net/u012551524/article/details/120548763

## VACUUM

用于恢复表中“死元组”占用的空间。

当记录被删除或更新（删除后插入）时，会创建一个死元组。

PostgreSQL 不会从表中物理删除旧行，而是在其上放置一个“标记”，以便查询不会返回该行。

当vacuum进程运行时，这些死元组占用的空间被标记为可被其他元组重用。

如果一个表没有被清空，它会变得臃肿，浪费磁盘空间而且会降低顺序表扫描的速度，而且在较小范围内也会降低索引扫描的速度

## Analyze

操作正如其名——它分析数据库表的内容并收集有关每个表的每一列中值分布的统计信息。

PostgreSQL 查询引擎使用这些统计信息来寻找最佳查询计划。

随着在数据库中插入、删除和更新行，列统计信息也会发生变化。

ANALYZE——要么由 DBA 手动运行，要么在 autovacuum 后由 PostgreSQL 自动运行——确保统计数据是最新的。

## 不要无故运行手动 VACUUM 或 ANALYZE

PostgreSQL 清理（自动清理或手动清理）可最大限度地减少表膨胀并防止事务 ID 回卷。

Autovacuum 不会恢复死元组占用的磁盘空间。但是，运行VACUUM FULL命令会这样做。

VACUUM FULL 有其性能含义。

* 目标表在操作期间被独占锁定，甚至阻止对表的读取。
* 该进程还会制作表的完整副本，这在运行时需要额外的磁盘空间。

我们建议不要运行 VACUUM FULL，除非膨胀率非常高，并且查询受到严重影响。

我们还建议使用最低数据库活动期。
最好不要在整个数据库上过于频繁地运行手动清理；目标数据库可能已经通过 autovacuum 过程进行了最佳清理。

因此，手动清理可能不会删除任何死元组，但会导致不必要的 I/O 负载或 CPU 峰值。

如有必要，手动清理应仅在需要时逐表运行，例如活动行与死行的比率较低，或自动清理之间的间隙较大。

此外，应在用户活动最少时进行手动vacuum。

Autovacuum 还使表的数据分布统计信息保持最新（它不会重建它们）。

手动运行时，ANALYZE命令实际上重建这些统计信息而不是更新它们。

同样，当统计信息已经通过常规自动清理进行最佳更新时重建统计信息可能会对系统资源造成不必要的压力。
您必须手动运行 ANALYZE 的时间是在将数据批量加载到目标表之后。现有表中的大量（甚至数百）新行将显着扭曲其列数据分布。新行将导致任何现有列统计信息过时。当查询优化器使用此类统计信息时，查询性能可能会非常缓慢。在这些情况下，在数据加载后立即运行 ANALYZE 命令以完全重建统计信息是比等待自动清理启动更好的选择。

## 数据表收缩用法：

```sql
VACUUM [({ FULL|FREEZE|VERBOSE|ANALYZE } [, ...])] [table_name [(column_name [, ...])] ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table_name ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ table_name [ (column_name [, ...] ) ] ]
```

参数解释：


| 参数                                                          | 释义                                                                                                                                                                                                                                              |
| ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| FULL                                                          | 选择"完全"清理，这样可以恢复更多的空间，但是花的时间更多并且在表上施加了排它锁``。 该方法也需要额外的磁盘空间，因为它写了一个表的新拷贝并且不释放旧的拷贝，直到操作完成。``  通常这应该只用于当一个大量的空间需要在这个表中回收时。 |
| FREEZE                                                        | [选择激进的行&#34;冻结&#34;。指定FREEZE相当于执行 VACUUM时将vacuum_freeze_min_age参数设为零。](http://postgres.cn/docs/9.3/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE)                                                                    |
| VERBOSE                                                       | 为每个表打印一份详细的清理工作报告。                                                                                                                                                                                                              |
| ANALYZE更新用于优化器的统计信息，以决定执行查询的最有效方法。 |                                                                                                                                                                                                                                                   |
| table_name                                                    | 要清理的表的名称(可以有模式修饰)。缺省时是当前数据库中的所有表。                                                                                                                                                                                  |
| column_name                                                   | 要分析的具体的字段名称。缺省是所有字段。若指定一个字段列表，就暗含ANALYZE                                                                                                                                                                         |


## VACUUM和VACUUM FULL的区别

| 区别                                                           | VACUUM                                                                                                                                                                                                                                                       | VACUUM FULL                                                                                                                                                                                                        |
| -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 被删除的数据所占用的物理空间是否被重新规划给操作系统。         | 否                                                                                                                                                                                                                                                           | 是                                                                                                                                                                                                                 |
| 执行效率                                                       | 只是状态置为操作，效率较高。                                                                                                                                                                                                                                 | 该命令会为指定的表或索引重新生成一个数据文件，``并将原有文件中可用的数据导入到新文件中，之后再删除原来的数据文件。``因此在导入过程中，要求当前磁盘有更多的空间可用于此操作。``因此该命令的执行效率相对较低。       |
| 删除大量数据之后                                               | 如果删除的记录位于表的末端，其所占用的空间将会被物理释放并归还操作系统。``如果不是末端数据，该命令会将指定表或索引中被删除数据所占用空间重新置为可用状态，那么在今后有新数据插入时，将优先使用该空间，直到所有被重用的空间用完时，再考虑使用新增的磁盘页面。 | 不论被删除的数据是否处于数据表的末端，``这些数据所占用的空间都将被物理的释放并归还于操作系统。``之后再有新数据插入时，将分配新的磁盘页面以供使用。                                                                 |
| 在执行VACUUM命令时，<br />是否可以并发执行针对该表的其他操作。 | 该操作是共享锁，因此可以与其他操作并行进行。                                                                                                                                                                                                                 | 该操作需要在指定的表上应用排它锁，因此在执行该操作期间，``任何基于该表的操作都将被挂起，知道该操作完成。                                                                                                           |
| 推荐使用方式                                                   | 为了保证数据表的磁盘页面数量能够保持在一个相对稳定值，可以定期执行该操作``，如每天或每周中数据操作相对较少的时段。                                                                                                                                           | 考虑到该操作的开销，以及对其他错误的排斥，推荐的方式是，``定期监控数据量变化较大的表，只有确认其磁盘页面占有量接近临界值时，``才考虑执行一次该操作。``即便如此，也需要注意尽量选择数据操作较少的时段来完成该操作。 |
| 执行后，其它操作的效率                                         | 相比于不执行任何VACUUM操作，其效率更高，但是插入的效率会有所降低。                                                                                                                                                                                           | 在执行完该操作后，所有基于该表的操作效率都会得到极大的提升。                                                                                                                                                       |
